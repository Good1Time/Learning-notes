### 7.1递归，预编译(上)

**函数是为了抽象规则**

 **写一个函数实现**N的阶乘

递归 好处==>符合人的思维模式,方便找规律

1.找规律 2.找出口(已知条件当出口)

递归让代码变得更加简洁	

**写一个函数求斐波那契数列**



**作用域初探**



**预编译**

JS 单线程   解释型语言

1. 语法(语义)分析
2. 预编译
3. 解释执行

*简述:函数声明整体提升(不论函数写在哪里,系统总是会把声明提到逻辑的最前面)变量的声明提升(变量的声明提升到逻辑的最前面)*

**` imply global` 暗示全局变量:即任何变量,如果变量未声明就赋值,此变量就为全局对象所有.**

1. 未经声明的变量直接赋值归 `window` 所有
2. 全局上的任何变量也归 `window` 所有

总结:一切声明的全局变量,全是 `window` 的属性,,`window` 就是全局的域

预编译的过程: 预编译发生在函数执行的前一刻

函数体内的预编译

1. 创建AO对象(Activation Object(活跃对象) 执行期上下文)
2. 找形参和变量声明,将变量和形参名作为AO属性名,值为 `undefined` 
3. 将实参和实参统一
4. 在函数体里面找函数声明,把函数声明的名作为属性名,值赋予函数体

预编译也存在全局变量中GO

1. 创建GO对象(Global Object)
2. 找变量声明,将变量作为GO属性名,值为 `undefined` 
3. 在函数体里面找函数声明,把函数声明的名作为属性名,值赋予函数体

## 7.1递归，预编译(下)

`arguments` 

  **隐式类型转换！！！，好好复习！！！**

记忆力

**讲练习题**

